<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>OOP in JavaScript</title>
</head>

<body>
  <script type="text/javascript">
    // Factory Pattern for Object Creation
    const makeGladiator = (name, attack, defense, hitPoints) => {
      return {
        name,
        attack,
        defense,
        hitPoints,
        sayName: function () {
          console.log(`Hello my name is ${this.name}`);
        }
      }
    }
    const jesse = makeGladiator('Jesse', 10, 12, 10),
      john = makeGladiator('John', 12, 10, 12);
    // Prototype pattern for Creating Objects
    function Gladiator(name, attack, defense, hitPoints) {
      this.name = name;
      this.attack = attack;
      this.defense = defense;
      this.hitPoints = hitPoints;
      this.weapon = "Sword";
    }
    Gladiator.prototype.sayName = function () {
      console.log('Gladiator Prototype called.');
      console.log(`Hello my name is ${this.name}`);
    }
    function v2makeGladiator(name, attack, defense, hitPoints) {
      return new Gladiator(name, attack, defense, hitPoints);
    }
    const v2jesse = v2makeGladiator('Jesse', 10, 12, 10),
      v2john = v2makeGladiator('John', 12, 10, 12);
    function Human(name, attack, defense, hitPoints) {
      this.name = name;
      this.attack = attack;
      this.defense = defense;
      this.hitPoints = hitPoints;
      this.weapon = new Weapon(1, 1);
    }
    function Weapon(howManyDie, typeOfDie) {
      this.howManyDie = howManyDie;
      this.typeOfDie = typeOfDie;
    }
    // This line introduces prototypal inheritance in which Humans inherit
    // from Gladiator which means all the Gladiator prototype functions will
    // be available on the Human objects.
    Human.prototype = new Gladiator();
    // If we don't use the line below then although we create Human objects
    // inherited from Gladiator prototype our objects will point to the
    // Gladiator constructor, since we inherit from it.
    Human.prototype.constructor = Human;
    const v3jesse = new Human('Jesse', 10, 12, 10),
      v3john = new Human('John', 12, 10, 12);
    function Animal(name, attack, defense, hitPoints) {
      this.name = name;
      this.attack = attack;
      this.defense = defense;
      this.hitPoints = hitPoints;
      this.weapon = new Weapon(1, 2);
    }
    Animal.prototype = new Gladiator();
    Animal.prototype.constructor = Animal;
    // This Animal prototype method overrides the Gladiator prototype method
    // If we didn't define this method then the object looks up in the
    // inheritance chain for existence of the method.
    Animal.prototype.sayName = function () {
      console.log(`Hey Human mein name ist ${this.name}`);
    }

    // There is no classes and instantiation in Prototypal Inheritance.
    // Instead it's all References and Delegation.

    // So whenever we set a same named property on an object then they don't actually override it in the __proto__
    // But instead  the lookup mechanism is like this:
    // They first look into it's own properties and if not found then it looks into __proto__ properties
    // But they don't override each other since both are different altogether.

    // If you want to use functions as constructors with new keyword then the  .prototype can be used since the .prototype property exists only on functions.
  </script>
  <script src="index2.js"></script>
</body>

</html>